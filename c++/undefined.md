# 에디안과 어셈블리

#### 엔디안\(Endianness\)

컴퓨터 메모리와 같은 1차원 공간에 여러 개의 연속된 대상을 배열하는 방법  
컴퓨터에서는 바이트를 배열하는 방법으로  
큰 단위가 앞으로 배열될 경우 빅 엔디안  
작은 단위가 앞으로 배열될 경우 리틀 엔디안으로 지칭한다.

* 리틀 엔디안
  * CPU에서 메모리를 읽는 방식
  * 메모리를 거꾸로 읽는 방식 --&gt; 값이 바이트 단위로 뒤집혀서 메모리에 올라간다
  * CPU에서 리틀 엔디안 방식으로 메모리를 읽는 이유는 메모리에 저장된 값의 하위 바이트만 사용될 경우가 있기 때문이다

    ```cpp
    int a = 1000;
    int b = 100000;

    cout << a << endl
      << (short)a << endl;

    cout << b << endl
      << (short)b << endl;
    ```

  * 해당 코드에 대한 메모리를 확인해본 결과

    * 1바이트 단위의 경우와 4바이트 단위의 경우에서 반대로 배열된 것을 확인할 수 있었다.

      ![endian test](https://user-images.githubusercontent.com/29733789/111101700-ccee8a00-858d-11eb-86cd-3920a7a37eac.png)

    * 코드의 결과를 확인해 보면

      ![image](https://user-images.githubusercontent.com/29733789/111101965-5605c100-858e-11eb-8186-c64f3ac073b5.png)

      * 0x03e8 은 정수로 1000, 0x86a0 는 -31072 로 대응되는 것을 확인할 수 있다.
* 빅 엔디안
  * 네트워크 장비에서 메모리를 읽는 방식
  * 네트워크 장비들이 읽을 데이터는 따로 변환을 해주어야 한다.

C++에서 컴파일된 어셈블리 코드의 경우 컴파일러 종류, 컴파일 옵션 등등에 따라 조금씩 다를 수 있다.

멀티스레드의 경우 rep같은 명령어가 완전히 수행되지 않고 다른 작업을 진행할 수 있음

visual studio에서 릴리즈로 빌드 시 최적화 컴파일

* 컴파일러가 내 소스코드를 마음대로 뒤집을 수 있음
  * 불필요한 변수, 필요없는 동작들을 없애버림
  * 해당 코드 자체가 사라지는 것임 --&gt; 최적화로 인해 변경된 부분은 브레이킹 포인트를 잡을 수 없음, 성능이 좋아지는 이유
  * 함수 호출 자체는 굉장히 무거운 동작
    * 최적화 컴파일에서는 inline이 가능한 부분은 inline으로 처리

.pdb?

* program database file
* 소스코드와 어셈블리를 매핑해주는 파일
* 실행파일과 세트, 해당 파일이 존재하지 않는다면 디버깅이 불가능할 정도로 어려움

////////////////////////////////////////////////////////////////////// 어셈블리

ebp

* 스택 메모리의 시작 주소
* 잘못 변경하게 되면 스택이 깨지는 버그 발생

esp

* 현 스택의 포인터

eax

* 산술, 논리 연산에 사용되는 레지스터

ecx

* 반복문 등의 카운팅을 위한 레지스터

esi

* 데이터 복사 시 원본 주소

edi

* 데이터 복사 시 목적지 주소

mov A B

* A 주소에 B 값 입력

cf\) 32bit 기준 : ebp에서 올리가면서 메모리 계산 64bit 기준 : rsp에서 내려가면서 메모리 계산

예제 코드 및 어셈블리 입력

