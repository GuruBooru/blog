# 캐시 메모리 / 메모리 관리 체계

#### 캐시 메모리

* write through : RAM까지 값 변경
* write back : 캐시 메모리 해제 시 값 변경, 데이터 캐시 메모리의 기본 동작
  1. a의 값 변경
  2. 다른 코어들에게 캐시 무효화 
  3. 해당 값 삭제
  4. write back으로 L3에 저장
  5. 해당 코어에 값이 없으므로 다른 캐시 메모리에서  찾아 읽음

![](../.gitbook/assets/write-back.png)



#### Windows 메모리 관리 체계

* 각 프로세스 별 가상 메모리 테이블 존재 : 해당 메모리 테이블이 우리가 흔히 말하는 메모리를 뜻함
* 프로세스 내부에서 메모리 주소를 통해 다른 프로세스에 접근할 수 없음
  * 실수로 다른 메모리에 접근할 수 없는 것
  * 의도적으로 접근할 수 있음 
* 가상 메모리 테이블은 MMU\(Memory Management Unit\)를 통해 실제 RAM과 연결된다.

![](../.gitbook/assets/.png%20%283%29.png)

* 이 과정에서 물리 메모리와 가상 메모리를 맵핑하는 page라는 단위가 사용

  * page의 기본 할당 단위는 4Kbyte →최소 할당 단위
  * 예약 : 물리 메모리에 핑 X,

                   : 64Kbyte 단위

                   : 프로세스 내부에서 해당 부분을 사용할 것이다 미리 선언  


  * commit : 실제 쓸 수 있는 메모리에 핑

    * WinAPI에서는 VirtualAlloc이라는 함수를 제공하여 페이지 단위로 할당받을 수 있음
    * 해당 함수로 할당 받을 경우 힙을 사용하지 않고 메모리를 할당받은 것이 됨
    * 대신 주소값 계산하여 4Kbyte 단위로 할당해야함

  * free : 물리 메모리 해제 

* 페이지 아웃 : 오랫동안 사용하지 않은 메모리를 디스크로 빼냄
  * 메모리가 얼마나 차있는지는 중요하지 않음
  * 제어 방법 : 제어판 - 시스템 - 고급 시스템 설정 - 고급 - 성능 - 고급 - 가상메모리
    * default : 자동 관리
    * 페이징 파일 없음 : 페이지 아웃 없음
    * 파일 입출력이 잦은 디스크는 피해서 설정하는 것이 좋음 
* 페이지 폴트 : 가상메모리에서 MMU를 통해 물리 메모리와 매치하지 못하는 경우
  1. 커밋은 했지만, 할당되지 않은 경우
  2. 예약만 한 곳을 접근하는 경우 
* 가상 메모리 상에서 이어져 있다고 해도, 물리 메모리 상에서 페이지는 이어지지 않을 수도 있음 
* 메모리 단편화
  * 메모리를 다양하게 할당 / 해제하면서 전체 메모리의 잔여 공간은 충분하지만, 연속된 공간이 생기지 않는 것을 방지
  * 하드 디스크의 경우 디스크 조각 모음을 사용 but 메모리에서는 이런 방법 사용 X
  * 규격화를 통해 해결 → 완전히 나타나지 않게 할 수는 없음, 그나마 적게 나타나게 하는 방법
    * 다소 낭비가 있음
    * 조금만 필요하다고 해도, 정해진 사이즈만큼 할당
    * OS : 페이지 단위
    * 힙 메모리 : 여러 종류의 규격을 만듦 → 버킷\(12종류\) 단위로 관리                   : low fragment heap
    * 가상 메모리와  물리 메모리의 핑 코스트 절약 
  * 캐시 메모리에서의 메모리 단편화
    * 캐시 메모리에서 한번에 메모리의 위치를 계산할 수 있어야함
    * 캐시 메모리 주소에서 하위 6bit를 제외하고, 일정 부분을 가지고 인덱스 계산
    * 버려진 6bit는 인덱스 내부에서의 위치
    * 인덱스를 넘어서 중복될 경우, 인덱스의 앞부분을 태그로 저장
    * 태그를 비교하여 캐시 히트 / 미스를 판단

