# 구조체 / 캐시 메모리 / Windows 메모리 관리 체계

#### 구조체

* 컴퓨터 입장에서는 구조체로 묶인 타입의 개념이 아닌, 각각의 변수를 지역 변수로 취급하여 접근
* 포인터로 접근 시
  * 구조체의 주소값 push
  * 구조체의  주소값에서 해당 변수까지 연산하여 접근
  * '가장 많이 접근할 대상을 첫 번째로 놓아야 연산이 수월하다 → 해당 변수로 이동하는 연산X
* 구조체 패딩 규칙
  1. 멤버 변수 중 가장 크기가 큰 타입을 기준으로 전체 구조체의 크기가 결정
  2. 구조체 변수의 시작점을 0으로 두고, 각 멤버 변수의 주소는 자신의 크기에 맞게 떨어져야 한다.
     * 해당 조건은 클래스의 멤버 변수, 함수의 지역 변수에도 똑같이 적용

> 패딩을 하는 이유?
>
> * 캐시 메모리의 경우 캐시 라인이라는 64byte의 메모리 블럭을 구성하고, 해당 블럭을 통채로 가져옴
> * 패딩을 하지 않을 경우, 변수가 2개의 블럭에 걸쳐서 할당되었을 때
>   * 블럭 2개를 읽어들어야하기 때문에 성능 ↓
>   * 멀티 스레드의 경우 값이 바뀌게 될 수 있음
>
> 해당 문제들을 방지하기 위해 컴파일러 단계에서 규격을 맞춰준다

* \#pragma pack ~ \#pragma pop
  * \#pragma pack 패딩 크기 : 패딩의 크기를 지정
  * \#pragma pop : 패딩 크기를 원래대로 되돌림
  * 주로 네트워크 프로그래밍에서 사용

    * 네트워크 프로그래밍에서 네트워크 트래픽과 직접적으로 연관

#### 캐시 메모리

* write through : RAM까지 값 변경
* write back : 캐시 메모리 해제 시 값 변경



#### Windows 메모리 관리 체계

* 각 프로세스 별 가상 메모리 테이블이 존재 : 해당 메모리 테이블이 우리가 흔히 말하는 메모리를 뜻함
* 프로세스 내부에서 메모리 주소를 통해 다른 프로세스에 접근할 수 없음
* 가상 메모리 테이블은 MMU를 통해 실제 RAM과 연결된다.
  * 이 과정에서 물리 메모리와 가상 메모리를 매핑하는 page라는 단위가 사용
  * page의 기본 할당 단위는 4kbyte
  * 예약 : 물리 메모리에 매핑 X, 64kbyte 단위, 프로세스 내부에서 해당 부분을 사용할 것이다 미리 선언
  * commit : 실제 쓸 수 있는 메모리에 매핑
  * free : 물리 메모리 해제

