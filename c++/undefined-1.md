# 함수 호출방식 / 호출 규약

visual stduio에서 debug / release 모드 별 함수 호출 방식

* debug 모드

  * 증분 링크를 사용
  * 함수 컴파일 시 메모리 상으로 충분한 공간을 제공하며, 메모리 초기화 지원
  * 디버깅하면서 간단하게 코드를 변경할 수 있다.
    * 하지만 무조건 할 수 있다는 것이 아닌, 어느 정도까지만 가능

  > 증분 링크?
  >
  > 증분 링크란 매번 빌드 시 함수 주소를 찾아가 링크하는 방식이 아닌, 처음 빌드 시 함수 주소들을 테이블에 보관\(함수 테이블\)하여 다음 빌드 시 더 빠르게 링크할 수 있도록 하는 방식

* release 모드
  * 함수를 바로 호출
  * 컴파일 시 계산된, 필요한 만큼의 메모리만 제공
  * 따라서 debug 모드에서 컴파일에 성공했다고 하더라도 메모리를 조금이라도 침범하는 경우 release 모드로 넘어오게 되면 에러가 발생하게 된다.



#### 호출규약

> 호출규약?  
> 함수를 사용하는 호출자와 호출 당하는 함수인 피호출자 간의 함수의 인자를 전달하고 정리하는 방식에 대한 규약

* cdecl
  * C, C++ 프로그램에 대한 기본 호출 규약
  * 스택이 호출자에 의해 지워지기 때문에 가변 인자를 가지는 함수 정의 가능
  * 함수 호출마다 스택을 정리하는 코드를 추가 → stdcall보다 더 큰 크기의 실행파일을 만듦
  * 인수 전달 순서 : 오른쪽 → 왼쪽
  * 스택 유지 관리 책임 : 호출하는 함수가 인수 처리
* stdcall
  * Win32 API 함수 호출에 사용되는 함수 호출 규약
  * 인수 전달 순서 : 오른쪽 → 왼쪽
  * 스택 유지 관리 책임 : 호출 당하는 함수가 인수 처리
  * 함수가 직접 스택을 정리하기 때문에 가변 인자를 가지는 함수 정의 불가능
* fastcall
  * 가능하다면 레지스터로 전달하는 함수 인자를 지정
  * x86 아키텍처에서만 적용 가능
  * 왼쪽에서 오른쪽으로 진행하며 발견된 첫 두 개의 DWORD나 그 보다 더 작은 인수가 레지스터로 전달
  * 다른 모든 인수들은 오른쪽에서 왼쪽으로 스택에 전달
* 그 외 호출규약들은 추가적으로 정리

