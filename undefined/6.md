# 6장 기본적인 리팩토링

* 리팩토링의 주된 작업은 코드를 포장하는 함수를 적절하게 정리하는 것
* 많은 문제들이 장황한 메소드로 인해 발생

> 1판과 2판에서 조금씩 다른 내용이 존재하여 이름을 혼용하여 사용
>
> 1판에서는 6~7장에 해당하는 내용을 2판에서는 6~8장에 걸쳐서 더욱 다양한 방법을 설명

## 함수 추출

* 어떤 코드를 그룹으로 묶어도 되겠다고 판단될 땐,  그 코드를 빼내어 목적을 잘 나타내는 이름의 메소드로 만들자
* 가장 많이 사용되는 기법 

### **동기**

* 메소드가 너무 길거나, 코드에 주석을 달아야만 의도를 이해할 수 있을 때 사용 
* 스터디원들끼리 적당한 함수 길이에 대해서 의논을 해봤고,  `대부분 한 눈에 코드를 이해할 수 있는 정도`가 적당한 함수 길이라고 결론을 내놓음 + 학교 수업에서 교수님들이 말하는 `적당한 길이는 30~40줄 정도`의 길이라고 설명한 적이 있음 **내 의견은 스크롤 하지 않고도 함수를 볼 수 있을 정도면 적당한 길이라고 판단 \(대략 30 중반\)** 
* 직관적인 이름의 간결한 메소드의 장점
  1. 다른 메소드에서 해당 기능을 쉽게 사용할 수 있음 \(간결한 메소드의 장점\)
  2. 상위 계층의 메소드에서 주석과 같이 작용할 수 있음 \(직관적인 이름의 장점\) → 함수를 까보지 않아도 함수의 기능을 대략적으로 파악할 수 있음
  3. 재정의에 수월 

### **방법**

1. 새로운 메소드 생성
2. 기존 메소드에서 빼낸 코드 복사
3. 빼낸 코드에서 기존 메소드의 지역변수 참조 찾기 → 새로 생성한 메소드의 지역변수나 파라미터로 사용
4. 빼낸 코드 안에서만 사용되는 임시변수 → 새로 생성한 메소드 안의 임시 변수
5. 추출 코드에 의해 변경되는 지역변수 → 반환값 or 결과를 관련 변수에 대입할 방법 찾기
6. 원본 메소드에서 빼낸 부분을 새로 생성한 메소드 호출로 수정

## 함수 인라인하기

* 함수 기능이 너무 단순하여 해당 함수의 기능을 호출하는 함수에 넣어버리고 함수 삭제

### 동기

* 함수명에 함수의 모든 기능이 반영될 정도로 함수 기능이 지나치게 단순할 경우 사용
* 인다이렉션을 통해 해결할 수 있지만, 불필요한 인다이렉션은 오히려 장애물 
* 잘못 쪼개진 함수에도 적용 가능 잘못 쪼개진 함수를 하나의 큰 메소드로 결합 → 합친 메소드를 다시 기능에 맞게 추출 
* 함수를 메소드 객체로 전환하기 전에 이 방법을 먼저 실시하면 좋을 때가 많음
* 과다한 인다이렉션과 동시에 모든 함수가 다른 함수에 단순히 위임하고 있는 경우 실시

### 방법

1. 함수 재정의 확인 → 함수가 하위 클래스에 재정의되어 있을 경우, 실시 X
2. 함수를 호출하는 부분 찾아 함수 내용으로 교체
3. 함수 정의 삭제

* 재귀 처리, 여러 반환 지점 처리, 접근 메소드가 없는 경우 등  복잡한 상황에서는 해당 기법 사용 X

## 변수 인라인하기

* 간단한 수식을 대입받는 임시변수로 인해 다른 리팩토링 기법 적용이 어려울 경우, 해당 임시변수를 참조하는 부분을 수식이나 함수로 치환

### 동기

* 임시 변수를 함수 호출로 전환하는 방법을 사용하는 도중에 병용하게 되는 경우가 많음
* 해당 방식만 순수하게 사용되는 경우는 함수 호출의 결과값이 임시변수에 대입될 때뿐

### 방법

1. 대입문의 우변에 문제가 없는지 확인
2. 임시 변수를 const 선언
3. 해당 임시 변수를 참조하는 모든 부분을 찾아 우변의 수식으로 치환
4. 하나씩 수정하며 컴파일 & 테스트
5. 임시변수 선언 & 대입문 삭제

## 변수 이름 바꾸기

### 동기

* 수식이 너무 복잡할 경우, 수식의 결과나 수식의 일부분을 직관적 이름의 임시변수에 대입
* 조건문에서 각 조건 절을 가져와 직관적인 이름의 임시변수를 사용하여 그 조건의 의미를 설명할 때 많이 사용
* 긴 안고리즘에서 임시 변수를 사용하여 계산의 각 단계 설명에 사용
* 생각없이 남용할 경우, 함수만 복잡해지고, 코드 보는 사람은 이해하기 어려워짐
* 메소드 추출의 경우가 비슷한 기능에 장점이 더 많지만,  메소드 추출을 할 수 없는 경우 해당 기법 실시

### 방법

1. 임시변수 const 선언, 복잡한 수식의 한 부분의 결과를 대입
2. 해당 수식의 대입한 부분을 임시변수로 치환
3. 수식의 다른 부분을 1~2와 같이 실시

## 임시변수 분리

### 동기

* 루프 변수 나 값 누적용 임시변수가 아닌 임시 변수에 여러번 값이 대입될 경우 각 대입마다 다른 임시변수를 사용하자 → 각각 변수마다 목적을 가지고 사용해서 의도를 명확하게 명시하자 
* 버그를 찾음에 있어 각 단계별 에러를 체크하는 등 로깅에 도움

### 방법

1. 선언문과 첫 대입문에 있는 임시변수 이름 변경
2. 이름을 바꾼 새 임시변수를 const 선언
3. 해당 임시 변수의 모든 참조 부분을 두 번째 대입문으로 수정
4. 해당 방법을 차례로 선언하며 각 선언문 별 임시변수 이름 변경 + 대입문 참조 수정

## 매개변수로의 값 대입 제거

### 동기

* 매개변수로 값을 대입하는 코드가 있을 경우, 임시변수에 대입하여 수정하자
* 매개변수가 오염될 수 있기 때문에 메소드 파라미터에 const를 사용하여 오염을 막을 수 있음

### 방법

1. 매개변수 대신 사용할 임시 변수 선언
2. 임시변수에 매개변수 값 대입
3. 매개변수를 대입하는 부분을 임시변수로 수정

## 여러 함수를 클래스로 묶기

### 동기

* 지역변수 때문에 함수 추출을 적용할 수 없는 긴 함수가 있을 때, 그 함수 자체를 모아 객체로 전환해서 모든 지역변수를 객체의 필드로 만들자

### 방법

1. 전환할 메소드들을 묶을 새 클래스 생성
2. 원본 함수가 들어있던 객체를 나타내는 const 필드 추가, 원본 함수 안의 각 임시변수와 매개변수에 해당하는 속성 추가
3. 새 클래스에 원본 객체와 각 매개변수를 받는 생성자 작성
4. 원본 메소드에서 쪼갤 부분은 쪼개기

## 알고리즘 전환

* 더 깔끔한 기법을 사용하자

