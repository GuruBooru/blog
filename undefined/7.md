# 7장 객체 간의 기능 이동

* 객체 설계에서 `기능을 어디에 넣을지 판단하는 것`은 가장 중요한 일 중 하나 
* 기능을 넣을 적절한 위치를 찾는 문제는 `함수 이동`과 `변수 이동`을 실시해서 기능을 옮기면 해결 → `변수 이동` 후 `함수 이동`을 실시하는 것이 수월 
* 클래스가 방대해지는 원인은 대개 기능이 너무 많기 때문 → `클래스 추출`을 통해 일부 분리 
* 클래스에 기능이 너무 적어질 경우 → `클래스 내용 직접 삽입`을 통한 클래스 병합 
* 대리 클래스가 사용 중일 경우 → `대리 객체 은폐`   대리 클래스를 은폐 시 해당 클래스를 소유한 클래스의 인터페이스가 변경될 경우, → `과잉 중개 함수 제거` 
* 특이 케이스
  * 외래 클래스에 함수 추가
  * 국소적 상속확장 클래스 

## 함수 옮기기

### 동기

* 클래스에 기능이 너무 많거나, 다른 클래스와의 의존성이 클 경우  
* 일부 속성을 옮긴 후 실행하는 것이 좋음\(변수 이동\)
* 판단이 쉽지 않을 경우, 다른 함수를 먼저 살펴보고 알아서 판단\(....?\)

### 방법

1. 원본 클래스에 정의되어 있는 원본 함수에 사용된 모든 기능 검사 → 해당 기능들을 전부 옮겨야 할지 판단
   * 옮길 함수에만 사용되는 기능도 함수와 같이 옮겨야 함
   * 다른 함수에서도 사용된다면 고려 
2. 원본 클래스의 하위 클래스와 상위 클래스에서 해당 함수에 대한 선언 찾기

   * 다른 선언이 있다면 대상 클래스에도 재정의를 넣을 수 있는 경우에만 옮길지 말지 판단

3. 대상 클래스 내부에 함수 선언, 원본 함수 복사, 대상 클래스에서 잘 수행하도록 수정
   * 함수가 원본 객체를 참조할 경우, 원본 객체를 참조할 방법 찾기
   * 예외처리 코드를 어느 곳에서 수행할지 결정
4. 원본 객체에서 대상 객체를 참조할 방법 찾기
5. 원본 함수를 위임 함수로 전환
6. 컴파일 & 테스트 후 원본 함수를 삭제하거나 위임 함수로 사용 원본 함수 삭제 시 기존의 참조를 대상 함수의 참조로 수정

## 변수 옮기기

* 어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용되는 경우,  대상 클래스 안에 새 필드를 선언하고 필드 참조 부분을 전부 새 필드 참조로 수정

## 클래스 추출

### 동기

* 두 클래스가 처리해야 할 기능이 한 클래스에 들어 있는 경우,  새 클래스를 만들고 기존 클래스의 관련 필드와 메소드를 새 클래스로 옮김
* DDD에서 도메인 서비스를 만드는 동기와 유사 \(DDD 7장 참조\) [https://app.gitbook.com/@123gudehsdl/s/study/~/drafts/-MbZgHXMbLtGVCWlIWml/ddd-domain-driven-design/7](https://app.gitbook.com/@123gudehsdl/s/study/~/drafts/-MbZgHXMbLtGVCWlIWml/ddd-domain-driven-design/7) 
* 주로 함께 변화하거나, 서로 유난히 의존적인 부분을 클래스로 떼어내기 좋음

### 방법

1. 클래스의 기능 분리 방법 결정
2. 분리한 기능을 넣을 새 클래스 작성
3. 원본 클래스에서 새 클래스로의 링크 만들기
4. 옮길 변수마다 변수 이동 적용
5. 함수 이동을 통해 원본 함수를 새 클래스로 이동
6. 각 클래스를 검사하여 인터페이스 줄이기 양방향 링크가 있을 경우, 단방향으로 바꿀 수 있는지 확인
7. 새 클래스를 접근할 수 있게 할지 결정
   * 여러 곳에서 접근 가능할 경우, 왜곡의 위험 고려하여 결정

* 두 결과 클래스에 따로 락을 걸 수 있기 때문에 병렬 수행에 용이
* 두 객체에 동시에 락을 걸 경우, 트랜잭션과 다른 종류의 공유 락 영역으로 넘어감 → 해당 영역은 얻는 것에 비해 많은 작업을 요구하는 경우가 많다.

## 클래스 인라인하기

* 클래스에 기능이 너무 적을 경우, 해당 클래스의 모든 기능을 다른 클래스로 합쳐 넣고 원래 클래스는 삭제

## 위임 숨기기

### 동기

* 클라이언트가 객체의 대리 클래스를 호출할 경우, 대리 클래스를 감추는 함수를 서버에 작성
* 클라이언트와 서버 사이에 일종의 인터페이스를 두고 서로의 변경이 영향이 가지 않게 하는 것 같음

### 방법

1. 대리 객체에 들어 있는 각 메소드를 대상으로 간단한 위임 메소드 작성
2. 클라이언트를 수정하여 서버를 호출하게 변경
3. 대리 객체와 관련된 클라이언트가 없게 되면, 서버에서 대리 객체가 사용하는 메소드 삭제

## 중개자 제거하기

### 동기

* 클래스에 자잘한 위임이 너무 많을 경우, 대리 객체를 클라이언트가 직접 호출
* 위임 숨기기에 반대되는 내용
* 위임 숨기기의 경우 클라이언트가 대리 개체의 새 기능을 사용할 때마다 서버에 간단한 위임 메소드를 추가해야 한다는 단점 → 대리 개체가 커짐에 따라 서버의 구현도 같이 커짐
* 은폐의 적절한 정도는 시간을 두고 조금씩 수정하면서 결정

> 리팩토링에서는 후회를 하는 것이 아닌, 필요할 때마다 보수하는 구조로 생각해야 함

## 외래 클래스에 함수 추가

### 동기

* 사용 중인 서버 클래스에 메소드를 추가할 경우, 그 클래스를 수정할 수 없을 경우, 클라이언트 클래스 안에 서버 클래스의 인스턴스를 인자로 받는 메소드 작성
* 새로 만든 메소드를 외래 메소드로 만들면 원본 메소드의 본래 위치를 명확하게 명시할 수 있음

> 외래 메소드?
>
> * 해당 외래 클래스의 인스턴스를 인자로 받는 정적 유틸 메소드
> * 해당 클래스 내부에서 선언할 수 없는 경우 사용

* 외래 메소드를 사용하는 것은 임시방편에 불과 가능하면 외래 메소드를 원래 있어야 할 위치로 옮기자

## 국소적 확장 클래스 사용

### 동기

* 사용 중인 서버 클래스에 여러 기능이 모자랄 때, 새 클래스를 작성하고, 그 안에 필요한 메소드를 작성, 해당 클래스를 원본 클래스의 하위 클래스나 래퍼 클래스로 상속확장

> 외래 클래스에 함수 추가 vs 국소적 확장 클래스 사용
>
> * 외래 클래스에 함수 추가 : 확장할 기능이 적은 경우 사용 : 외래 클래스의 인스턴스를 인자 받아 정적 유틸 메소드를 만들자 
> * 국소적 상속확장 클래스 : 외래 클래스를 상속해서 기능을 추가하자



