# 3장 코드의 구린내

### 리팩토링은 언제 실시해야 할까?

* 리팩토링이 반드시 필요하다는 시점이나 기준은 없음 자신이 해야겠다고 생각한 순간, 진행하며 판단의 기준은 충분한 연습을 통해 감을 잡는 방법 밖에 없음

### 중복 코드

* 똑같은 코드 구조가 두 군데 이상 있을 경우, 그 부분을 하나로 묶는다

### 장황한 메소드

* 최적의 상태로 장수하는 객체 프로그램을 보면 공통적으로 메소드 길이가 짧음
* 짧은 메소드로 쪼갤 경우, 코드를 이해하기 위해 메소드의 기능을 빨리 파악해야함 그러기 위해서 메소드 명을 잘 정하는 것은 매우 중요

### 방대한 클래스

* 기능이 지나치게 많은 클래스에는 보통 엄청나게 많은 인스턴스 변수와 중복 코드가 존재
* 객체 지향에 맞지 않은 설계이기 때문에 클래스를 분리

### 과다한 매개변수

* 객체를 사용할 때 메소드에 필요한 모든 데이터를 전달하는 것이 아닌, 모든 데이터를 가져올 메소드만 전달 → 객체를 통해 전달하자!
* 호출되는 객체가 호출 객체에 의존하면 안될 때는 객체를 전달하는 것이 아닌, 다른 방식을 찾아야 한다.

### 수정의 산발

* 한 클래스가 다양한 이유로 인해 다양한 방식으로 자주 수정될 경우
* 변경 시에 한 개의 클래스나 모듈만 변경되도록 클래스를 분리, 변경 사항을 표시

### 기능의 산재

* 수정 시 여러 클래스에서 수많은 부분들을 고칠 경우
* 인터페이스가 변경된 것이 아닌 이상, 하나의 기능에 대한 코드가 여러 곳에 분산 되어있는 것 이를 리팩토링 하려면 하나의 기능에 대한 부분들을 모아 한 클래스 안에 넣어야 하며,  기존 클래스에 넣기 부적절해 보일 경우, 새로운 클래스를 만들어 넣는다.

### 잘못된 소속

* 어떤 메소드가 자신이 속하지 않은 클래스에 더 많이 접근하는 경우
* 더 많이 접근하는 클래스로 메소드 이동
* 하지만 메소드가 여러 클래스에 접근하는 경우도 있음 이런 경우 메소드를 다른 클래스에 들어갈 여러 부분으로 쪼개어 이동
* `전략 패턴(Stratagy Pattern)`, `방문자 패턴(Visiter Pattern)`, `위임 패턴(Self-Delegation Pattern)`의 경우  수정의 산발이 의심될 때 해결책으로 사용되며, 이런 경우는 위에 규칙을 따르지 않는다.

### 데이터 뭉치

* 동일한 몇몇 데이터 항목들이 여러 위치에 몰려있는 경우, 몰려있는 데이터를 객체로 묶어 사용
* 묶여있는 데이터들이 유효한지 확인하기 위해서 그 중 한 데이터 값을 삭제해보면 알 수 있음

### 강박적 기본 타입 사용

* 원시 타입만으로 클래스를 구성하는 것이 아닌,  ID와 같이 특수한 의미를 가지는 경우 해당 부분을 클래스로 전환하여 사용

### switch 문

* switch 문의 단점으로 반드시 중복이 생긴다고 책에서 설명하고 있음
* 보다 큰 단점으로 case의 갯수가 늘어날 경우, 한 눈에 보기 힘들어지는 것
* 이 부분에 대해서는 상속을 통한 재정의나 함수 포인터을 통한 재정의를 사용하여 수행

### 평행 상속 계층

* 기능의 산재의 특수한 상황
* 한쪽의 하위 클래스를 만들면, 그에 대응하는 다른 쪽 하위 클래스가 생기는 구조
* 한 상속 계층의 인스턴스를 다른 쪽 상속 계층의 인스턴스를 참조하게 만든다.

### 직무유기 클래스

* 리팩토링으로 인해 기능이 축소되거나, 쓸모 없어진 클래스가 있을 경우 이러한 클래스들을 계층에 맞게 합치거나,  클래스 사용하는 클래스 내부에 직접 삽입하는 등의 방식으로 해결한다.

### 막연한 범용 코드

* 아직 필요 없는 기능을 수행하기 위해 호출과 case 문을 남발하는 경우
* 별다른 기능이 없는 클래스나 모듈은 병합, 사용되지 않는 매개변수 제거를 통해 해결
* 메소드나 클래스가 테스트 케이스에서만 사용될 경우 막연한 범용 코드라 볼 수 있음

### 임시 필드

* 어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우
* 이런 변수들을 클래스로 만들어 관련 코드를 묶음

### 메시지 체인

* 한 객체가 다른 객체를 요청하면, 다른 객체다 또다른 객체를 연쇄적으로 요청하는 경우
* 이러한 체인의 결과 객체가 어느 대상에 사용되는지 확인하여 체인에서 빼낸다.

### 과잉 중계 메소드

* 과도하게 위임할 경우, 원리가 구현된 객체에 직접 접근하여 사용

### 지나친 관여

* 클래스끼리 private 영역을 과도하게 관여할 경우, 해당 클래스들을 분리, 지나친 관여를 줄여준다.

### 인터페이스가 다른 대용 클래스

* 기능은 같은데, 시그니처가 다른 메소드
* 프로토콜이 같아질 때까지 메소드를 이동하면서 기능을 옮긴다.

### 미흡한 라이브러리 클래스

* 라이브러리 클래스에 원하는 기능이 없는 경우 
* 원하는 기능이 몇 없는 경우, 새로운 클래스를 만들어 해당 클래스 안에서 기능을 수행할 수 있도록 구현 or
* 라이브러리 클래스를 상속받아 하위 클래스에서 구현

### 데이터 클래스

* 구조체의 느낌
* 해당 클래스를 사용하는 부분들을 찾아 기능을 옮긴다.

### 방치된 상속물

* 상속받은 메소드나 데이터의 일부가 필요 없는 경우
* 기존에는 잘못된 계층구조로 인한 문제로, 상위 클래스를 만들어 해당 클래스로 안쓰는 기능들을 옮김
* 하지만, 상속된 클래스가 기능은 재사용하지만, 인터페이스를 지원하지 않는 경우 상속을 위임으로 전환하여 계층구조를 없애는 방식으로 처리

### 불필요한 주석

* 주석이 코드의 구린내를 감추는 탈취제의 역할을 할 때가 많다
* `주석을 사용하여 기능을 설명` 할 때는 `메소드 추출`을 통해 따로 빼내야 한다. 주석을 사용하여 기능을 설명하는 것 자체가 메소드가 자신이 수행하는 일에 대해서 잘 표현하지 못한다는 반증이다.
* 또한, `메소드가 추출된 상태에서도 기능을 설명`해야 한다면, 이름이 잘 못 지어졌다고 생각할 수 있으므로, `메소드명을 변경`해야 한다.



