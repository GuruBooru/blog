---
description: '2021.06.09, 2021.06.14(발표)'
---

# 8장 데이터 체계화

* 데이터 연동과 관련한 리팩토링 기법에 대해서 설명하는 장

## 필드 자체 캡슐화

* 필드에 대해서 자체적으로 직접 접근할 수 있게 할 것이냐,  클래스 내부에서라도 접근 메소드를 사용하여 접근할 것이냐에 대한 문제 
* 직접 접근 방식
  * 코드를 더욱 알아보기 쉽다
* 간접 접근 방식
  * 메소드를 해당 정보를 가져오는 방식을 재정의 
* 상위 클래스 안의 필드에 접근하지만, `변수의 접근을 하위 클래스에서 계산된 값으로 재정의`해야 할 경우 사용

## 데이터 값을 객체로 전환

### 동기

* 개발 초기 단계에서 `원시 타입으로 데이터 항목을 표현`하던 것이 `점점 복잡해지는 경우`에 사용
* 데이터 항목을 담을 수 있는 객체로 전환

## 값을 참조로 전환

* 클래스에 같은 인스턴스가 많이 들어 있어서 이것들을 모아 하나의 객체로 만드는 경우, 그 객체를 참조 객체로 전환

> 값? 참조?
>
> * 참조 객체의 경우, 현실에서 하나의 온전한 객체에 대응한다고 설명할 수 있음
> * 둘이 같은지 검사하는 경우, 보통 고유의 ID가 있으며, 이를 비교하여 검사 
> * 값 객체의 경우, 단순히 데이터가 같은 것을 뜻한다
> * 값 객체의 경우, 값이 같으면 같은 것으로 취급, 따라서 보통 const로 만들고,  사본에 대해서는 신경 쓰지 않는다.

## 참조를 값으로 전환

* `참조 객체가 작고`, `수정할 수 없고`, `관리하기 힘들 경우`, 값 객체로 변환
* 참조 객체를 사용한 작업이 복잡해지는 순간이 참조를 값으로 바꿔야 할 시점
* 변경 불가에 대한 뜻을 명확히 할 것

## 배열을 객체로 전환

* 배열의 각 순서에 따라 의미를 다르게 넣는 경우가 있음
  * 0번에는 ID, 1번에는 .....
  * 이렇게 넣으면 의도를 파악하기 힘들어진다. → 이름이 있는 것도 아니고, 칸마다 의미를 기억해야 하는 쓸데없는 짓을 해야 함
* 구조체나 클래스로 해당 배열을 대체하자

## 관측 데이터 복제

* 계층구조가 체계적인 시스템에서 비즈니스 로직 처리 코드와 사용자 인터페이스 처리 코드가 분리되어 있음
* 기능은 간단하게 분리할 수 있지만, 데이터는 분리하기 어려운 경우가 많음 → 도메인 모델에 있는 데이터와 같은 의미를 가진 데이터가 컨트롤러에도 들어가야 하기 때문
* 이러한 시스템에서 도메인 모델의 데이터와 컨트롤러가 가지는 데이터의 동기화를 관측하는 패턴을 사용하는 것으로 복제할 수 있음 → 도메인 모델과 컨트롤러 사이에 옵저버 패턴을 사용

## 클래스의 단방향 연결을 양방향으로 전환

* 이중 포인터 사용을 줄이자
* 1:N 인 상황에서 보통 N이 1을 참조하여 가지고 있지만,  1이 N에 대해서 기능을 수행해야 할 경우 사용할 수 있음
* 1인 쪽에서 N인 방향으로 참조 리스트를 가지고 관리

## 클래스의 양방향 연결을 단방향으로 전환

* 서로 연결되어 있는 상황에서 한 클래스가 다른 클래스의 기능을 더 이상 사용하지 않을 경우 수행

> 양방향 연결의 단점
>
> 1. 좀비 객체가 발생하기 쉬움 좀비 객체 : 참조가 삭제되지 않아 제거되어야 함에도 남아서 떠도는 객체\(메모리 누수\) 
> 2. 양방향 연결로 인해 두 클래스가 서로 종속됨

## 매직 넘버를 enum으로 전환

* 특수한 의미를 가지는 리터럴 숫자를 그대로 사용하지 않고, enum 등을 활용하여 의미를 살린 이름의 상수로 작성하여 사용 
* 의미를 좀 더 명확하게 알 수 있음
* `매직 넘버를 그대로 사용할 경우`, 수정이 필요할 때 `하나하나 찾아서 수정`해야 하지만,   `enum 등을 활용할 경우`, 선언된 부분만 수정하면 모두 수정이 이루어짐

## 필드 캡슐화

* public 필드를 private로 전환, 필드용 읽기 쓰기 메소드 작성

## 컬렉션 캡슐화

* 컬렉션의 경우, `읽기는 조작이 불가는한 형식으로 반환`  쓰기 대신 `원소 추가와 삭제`

