# 4장 테스트 작성 + 5장 한줄 요약

* 리팩토링의 필수 전제조건은 견고한 테스트가 동행되어야 한다는 것

## 자가 테스트 코드의 가치

* 자가 테스트 코드를 작성하지 않는 프로그래머의 경우,  작업을 파악하거나, 설계하는 시간보다 디버깅에 시간을 쏟는 경향이 있다고 함 즉, `버그를 찾는 것이 버그를 수정하는 것보다 오래 걸림` 
* 예상 테스트 결과와 테스트 결과를 비교하게 하는 것으로 테스트를 자동으로 수행 + 예전에 수행했던 테스트들을 기록하고, 나중에 해당 버그가 발생 시, 원인을 쉽게 찾을 수 있음 \(버그 발생의 위치, 시점 등등\) 
* 테스트를 작성하기 가장 적합한 시점 중 하나는 프로그래밍을 시작할 때이다.
  * 기능 추가 시 테스트를 먼저 작성
  * 테스트를 작성하면서 추가하려고 한 작업에 대해서 자문
  * 테스트 작성 시 구현부가 아닌,  인터페이스에 집중
  * 코딩을 완료하는 시점이 테스트가 성공하는 시점으로 분명해짐 
* 여러 테스트 프레임워크가 있으며, 책에서는 JUnit을 사용한 예제를 보여준다. 하지만, 책 자체가 예전에 쓰여 방식이 오래되었고,  리팩토링에 대한 개념을 정리하고 싶은 것이지, 프레임워크에 대한 사용법을 정리하고 싶은 것이 아니 때문에 따로 정리하지는 않음 
* 리팩토링 시 작업 중인 코드를 연습할 때, 두세 개의 테스트만 실행
  * 기존에 테스트를 수행한 부분에 대해서 리팩토링을 진행하기 때문에 위험하다고 생각되는 케이스에 대해서 테스트를 수행하는 것으로 이해
  * 말 그대로 두세 개만 진행하는 것이 아닌, 완벽하게 모든 케이스에 대해서 테스트를 진행하는 것이 아니라고 생각함 
* 테스트 작성 시 고의적인 버그를 넣어 작성
  * 알고리즘 연습 시에도 비슷하지만,  반례를 찾아서 넣는 등 `공격적으로 코드를 테스트`하고, 그에 대한 `대비책을 마련`하는 것이 중요

## 단위 테스트와 기능 테스트

* 단위 테스트

  * 프로그래밍 생산성 향상의 목표
  * 매우 국소적, 하나의 패키에 안에서 효력을 발휘

* 기능 테스트
  * 소프트웨어 전반이 제대로 돌아가는지 확인
  * 시스템 전반을 최대한 블랙박스 취급
  * 버그 발견 시

    1. 버그 수정
    2. 버그를 출력하는 단위 테스트 추가

    를 수행

## 테스트 추가

* 버그 가능성이 거의 없는 부분은 테스트 작성 대상에서 제외 → 읽기 / 쓰기와 같은 간단한 동작이 아닌, 다른 중요한 부분에 집중 
* 잘못될 수 있는 경계 조건을 생각하여 그 상황에 대한 테스트에 집중 → 테스트를 실패하게 할 가능성이 잇는 특수 조건을 찾는 작업도 포함 
* 에러가 발생할 것 같은 부분에서는 해당 에러에 대한 테스트 추가
* 테스트는 위험이 있는 곳에 집중 → `코드에서 복잡해지는 부분`이 어딘지 파악하고, `에러 가능성이 높은 부분`을 중점으로 테스트 추가 
* 테스트 코드의 경우, 구린내가 난다고 해도 상관이 없음
  * 테스트 코드의 경우, 지속적으로 사용하는 것이 아닌 임시로 사용하는 쪽이기 때문에, 그리고 빠른 개발을 요하기 때문에  구린내가 난다고 해서 크게 문제가 발생하지 않는다고 생각한다.

## 5장 한줄 요약

* 6장부터 12장까지 소개할 리팩토링 기법에 대한 카탈로그



