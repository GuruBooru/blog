# 4장 리포지터리와 모델 구현

4장의 내용은 JPA를 기반으로 한 내용이 대부분이고, 스터디에서도 JPA 사용법을 작성한 것과 유사하다는 평을 많이 받았다.  
최대한 개념 위주로 정리하고자 노력해봤음

* 애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지터리를 구현하는 방법이 다름
  * 책에서는 선호하는 기술로 JPA를 꼽으며 예로 들고 있음

## 리포지터리

* 도메인 객체의 지속적 사용을 위해 도메인 객체를 보관하기 위한 도메인 모델
* 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속함 
* 리포지터리 기본 기능
  1. ID로 애그리거트 조회
     * 인터페이스는 애그리거트 루트를 기준으로 작성
     * 아이디에 해당하는 애그리거트가 존재하면 해당 애그리거트 리턴, 존재하지 않으면 null
  2. 애그리거트 저장
     * JPA의 경우 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하기 때문에 애그리거트를 수정한 결과를 저장소에 반영하는 메소드를 추가할 필요는 없음
  3. 삭제 기능의 경우 필요할 경우 구현할 수 있음  

## 매핑 구현

해당 파트는 굉장히 JPA와 연관되게 설명되어 있음

#### 기본 생성자

* 엔티티와 밸류의 생성자는 객체를 생성할 때 필요한 것을 전달받아 생성
* 불변 타입의 경우 필요한 모든 정보를 객체를 생성할 때 받아 사용하기 때문에 set 메소드를 따로 제공하지 않음 → 즉, 클래스에 생성자를 추가할 필요가 없음
* JPA의 경우 어노테이션을 통해 클래스를 매핑하려면 기본 생성자가 제공되어야 함.
  * Q. private 처리된 내부에 어떤 방식으로 접근
  * A. 어노테이션 내부에서 자바 리플렉션이라는 방법을 적용하면 private 처리된 내용이라도 외부에서 접근하게 할 수 있음. 해당 방식을 사용하여 접근하는 것으로 알고 있음 but, 리플렉션 자체는 성능에 굉장히 부담을 주는 것이라고 알고 있음

#### 필드 접근 방식 사용

* JPA에서는 필드와 메소드, 두 가지 방식으로 매핑 처리

1. 메소드 방식
   * 프로퍼티를 위한 get/set 메소드 구현
   * 도메인의 의도가 사라지고, 객체가 아닌 데이터 기반으로 엔티티를 구현할 가능성이 높음
   * set 메소드를 외부에 바로 제공하는 것이 아닌, 의도가 잘 드러날 수 있는 네이밍과 기능을 제공해야 함. 
2. 필드 방식
   * 엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도
   * 책에서는 해당 방법을 권장하고 있음

#### 밸류 타입의 프로퍼티를 한 개 칼럼에 매핑

* 두 개 이상의 프로퍼티를 가진 밸류 타입을 한 개 칼럼에 매핑하기 위해서 JPA 2.0 버전에서는 칼럼과 매핑하기 위한 프로퍼티를 따로 추가하고, get/set 메소드에서 실제 밸류 타입과 변환처리를 진행
* JPA 2.1에서는 변환 코드를 모델에 구현하지 않아도 됨
* AttributeConverter를 사용하여 변환 처리
* @Converter 어노테이션 적용 

#### 밸류 컬렉션은 별도 테이블에 매핑

* @ElementCollection / @CollectionTable 어노테이션 사용
* FK를 지정하는 등의 방식을 사용하여 연결

#### 밸류 컬렉션을 @Entity로 매핑하기

* 개념적으로는 밸류이지만, 구현 기술의 한계나 팀 표준으로 인해 @Entity 어노테이션을 사용해야 할 경우가 있음
* JPA 에서 프로퍼티는 클래스 상속 매핑을 지원하지 않기 때문에 발생할 수 있음

#### ID 참조와 조인 테이블을 이용한 단방향 M:N 매핑

* 애그리거트 간 집합 연관은 성능상의 이유로 피해야 함
* ID를 참조하는 것으로 애그리거트 간 단방향 M:N 연관은 밸류 컬렉션 매핑과 동일한 방식으로 설정
* 애그리거트를 직접 참조하는 방식의 경우 영속성 전파나 로딩 전략을 고민해야 하지만, ID를 참조하는 것으로 이런 고민을 할 필요가 없음



## 애그리거트 로딩 전략

* 매핑에서 가장 주의해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것
* 애그리거트를 로딩하는 방식으로는 즉시 로딩과 지연 로딩이 있다 
* 즉시 로딩
  * 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함께 로딩
  * 컬렉션에 대해서 즉시 로딩을 설정할 경우 성능에 문제를 줄 수 있음
  * 상태 변경
    * 상태 변경을 위해 애그리거트를 완전한 상태로 로딩할 필요는 없음
    * JPA는 트랜잭션 범위 내에서 지연 로딩 허용 
  * 표현 영역에서 애그리거트의 상태 정보를 보여줌
    * 별도의 조회 전용 기능을 구현하는 방식이 유리할 때가 많음 
  * 애그리거트가 완전한 상태여야 한다는 것음애그리거트를 저장하고 삭제할 때도 하나로 처리해야함
    * 저장 메소드는 애그리거트에 속한 모든 객체를 저장해야함
    * 삭제 메소드는 애그리거트에 속한 모든 객체를 삭제해야함

## 식별자 생성 기능

* 엔티티는 식별자에 따라 라이프 사이클이 결정되기 때문에 식별자 생성 기능은 중요한 기능
* 크게 3가지 방식
  1. 사용자가 직접 생성
  2. 도메인 로직
  3. DB를 이용한 일련번호 
* 식별자 생성 규칙이 있는 경우 엔티티를 생성할 때 이미 생성한 식별자를 전달하기 때문에 엔티티가 식별자 생성 기능을 제공하는 것보다는 별도 서비스로 식별자 생성 기능을 분리해야함
* 식별자 생성 규칙은 도메인 규칙이기에 도메인 영역에 위치 OR 리포지터리에 위치

## 4장 소감

원래 소감은 잘 안 쓰는데, 이번 장은 너무 JPA와 연관하여 내용을 진행했기에 뭔가 사용법을 읽는 느낌이 강하게 들었다.

