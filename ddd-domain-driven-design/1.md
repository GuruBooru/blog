# 1장 도메인 모델 시작

## 도메인

* 해결하고자 하는 문제 영역
* 한 도메인은 여러 하위 도메인으로 나뉠 수 있음
  * 하나의 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 이룸
  * 도메인이 제공해야 할 모든 기능을 구현하는 것이 아님
  * 하위 도메인의 구성은 상황에 따라 달라짐

## 도메인 모델

* 특정 도메인을 개념적으로 표현한 것
* 도메인 자체를 이해하기 위한 개념 모델
* 장점
  * 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움
* 표현 방법
  * 매우 다양함\(클래스 다이어그램, 상태 다이어그램, 그래프 등등\)
  * 상황에 맞게 이해하기 용이한 방법으로 표현하면 됨
* 도메인 모델은 개념모델 → 구현 기술에 맞는 구현 모델이 따로 필요함
  * 개념 모델 : 순수하게 문제를 분석한 결과물 → 요구사항과 관련된 요소 인 
  * 구현 모델 : 데이터베이스, 트랜잭션 처리, 성능 등 실제 구현에 필요한 것들을 고려한 모델  
    → 설계와 관련된 요소

  
* 하위 도메인과 모델
  * 하위 도메인 별로 같은 용어라도 의미가 달라질 수 있음
    * ex\) 온라인 쇼핑몰에서 카탈로그 도메인의 상품 : 상품 가격, 상세 내용을 담는 정보        배송 도메인에서 상품 : 실제 배송되는 물리적인 물건
  * 도메인에 의해 용어의 의미가 변경되기 때문에 하위 도메인을 하나의 다이어그램에 표현할 경우 혼란을 야기
  * 모델의 각 구성요소는 도메인을 한정했을 때 의미가 완전해지기 때문에, 각 하위 도메인 별 모델을 따로 만들어야 함

## 도메인 모델 패턴

* 4개의 계층으로 구성된 아키텍처
  * 사용자 인터페이스
    * 사용자의 요청 처리 및 정보 제공 
  * 응용
    * 사용자가 요청한 기능 실행
    * 도메인 계층을 조합하여 기능 실행 
  * 도메인

    * 시스템이  제공할 도메인 규칙 구현

  * 인프라스트럭처
    * 외부 시스템과의 연동 처리 
* 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴 
* 도메인 계층

  * 핵심 로직 구현
  * 도메인 계층에만 핵심 로직을 구현하기 때문에 규칙 변경 또는 확장 시 다른 코드에 영향을 덜 주며, 변경 내역을 모델에 반영할 수 있음



  * 도메인 모델 도출
    * 요구사항에서 출발, `핵심 구성요소, 규칙, 기능`을 찾는 것

## 엔티티와 밸류

### 엔티티

* 식별자를 갖는다
* 식별자는 엔티티 객체마다 고유, 각 엔티티는 서로 다른 식별자를 가짐
* 엔티티를 생성하고, 속성을 바꾸고, 삭제할 때까지 식별자는 유지
* 식별자가 고유하기 때문에 식별자가 같으면 두 엔티티는 같다고 판단할 수 있음 
* 식별자 생성
  * 도메인의 특징과 사용하는 기술에 따라 달라짐 
  * 특정 규칙에 따라 생성
  * UUID
  * 값을 직접 입력
  * 일련번호\(시퀀스나 DB AI 등등\)

### 밸류

* 개념적으로 완전한 하나를 표현할 때 사용
* 의미를 보다 명확하게 표현하기 위해 밸류 타입을 사용하는 경우도 있음

```java
public class OrderLine{
    private Product product;
    private int price;
    private int quantitiy;
    private int amount;
}
```

```java
public class Money{
    private int value;
    
    public Money(int value){
        this.value = value;
    }
    
    public int getValue(){
        return value;
    }
}

public class OrderLine{
    private Product product;
    private Money price;
    private int quantitiy;
    private Money amount;
}
```

#### 아래의 코드가 의미를 파악하기 더 쉽다 + 밸류 타입을 위한 기능 추가 가능

* 밸류 객체의 데이터 변경 시 기존 데이터를 바꾸는 것보다는 변경한 데이터를 갖는 새로운 밸류 객체를 생성하는 것이 선호된다 → 데이터 변경 기능을 제공하지 않는, 불변 타입
  * 불변으로 구현하는 이유 : 안전한 코드 작성 

#### 엔티티와 밸류 타입의 차이

* 생명주기 유무
  * 엔티티 : 라이프사이클 존재
  * 밸류 : 라이프사이클 없음 
* 객체 간 비교  방법
  * 엔티티 : 식별자 사용
  * 밸류 : 모든 속성이 같은지 비교

## 도메인 메소드에 set 메소드 넣지 않기

* set 메소드의 단점
  1. 비즈니스적 개념을 나타내기 어렵다
     * 단순히 setter는 상태 값만 변경하는지,  상태 값에 따라 다른 처리를 위한 코드가 같이 작동되는지 알기 어려움
  2. 도메인 객체를 생성할 때, 완전한 상태가 아닐 수 있음
     * setter를 사용하여 값을 설정하게 되면, 불완전한 상태에서 로직을 수행할 가능성이 있음
     * 생성 시점에서 필요한 모든 것을 전달 → setter가 필요 없어짐 
* 불변  밸류 타입 사용 시 자연스럽게 밸류 타입에는 setter를 구현하지 않음

cf\) DTO\(Data Tranfer Object\)

* `표현층` 과 `도메인 계층` 이 데이터를 서로 주고 받을 때 사용하는 일종의 구조체
* 옛날 프레임워크 : DTO에 get/set 구현
* 현재 프레임워크, 개발 도구 : private 필드에 직접 값을 할당하는 기능 제공 → 프레임워크를 이용해서 데이터를 전달 받을 수 있음
* DTO도 불변 객체가 되어 불변의  장점을 DTO까지 확장 가능

#### 



