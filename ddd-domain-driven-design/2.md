# 2장 아키텍처 개요

## 네 개의 영역

* 아키텍처를 설계할 때 출현하는 전형적인 영역이  `표현`, `응용`, `도메인`, `인프라스트럭처` 로 구성된다. 
* 표현 영역 \(Presentation\)
  * `어떻게 표현할 것인가` 에 대한 영역
  * 사용자의 요청을 받아 해석, 응용 영역에 전달
  * 응용 영역의 처리 결과를 사용자가 이해할 수 있는 형식으로 출력
  * 스프링에서는 MVC 프레임워크가 해당 역할 수행

> 사용자?  
> 웹 브라우저 이용자, REST API를 호출하는 외부 시스템 등 도메인을 사용하는 주체자

* 응용 영역 \(Application\)
  * `어떤 순서로 진행할 것인가` 에 대한 영역
  * 시스템이 사용자에게 제공해야 할 기능 구현
  * 기능 구현을 위해 도메인 영역의 도메인 모델 사용
  * 로직을 직접 수행하기보다는, 도메인 모델에 로직 수행을 위임 
* 도메인 영역
  * `무엇을 구현할 것인가` 에 대한 영역
  * 도메인 모델 구현 → 도메인의 핵심 로직 구현 
* 인프라스트럭처 영역 \(infrastructure\)
  * `무엇을 사용하여 구현할 것인가` 에 대한 영역
  * 논리적인 개념보다 실제 구현에 필요한 기술에 대해 다룸
  * 아키텍처에 존재하는 4가지 영역은 각자 구현 기술을 사용한 코드를 직접 만드는 것이 아닌, 인프라스트럭처 영역에서 제공하는 기능을 사용하여 필요한 기능 개발

## 계층 구조 아키텍처

![](../.gitbook/assets/image%20%2810%29.png)

* 특징
  * 상위 계층에서 하위 계층으로의 의존만 존재
  * 상위 계층은 바로 아래 계층에만 의존을 가져야함 → 구현의 편리를 위해 계층 구조를 유연하게 적용할 수는 있음
  * 일반적으로 표현, 응용 영역은 도메인 영역을 사용 도메인 영역은 인프라스트럭처 영역을 사용
    * 표현, 응용, 도메인 영역이 인프라스트럭처 영역에 종속되는 문제 발생
    * 그 영향으로

    1. 동작 테스트를 위해서는 인프라스트럭처의 기능도 테스트 → **테스트의 어려움**
    2. 구현 방식을 변경하기 어려움 →**기능 확장의 어려움**

## DIP \(Dependency Inversion Principle\)

* 위에 발생한 문제점을 `의존성 역전 원칙` 을 통해 해결할 수 있음 
* 고수준 모듈 : 의미 있는 단일 기능을 제공하는 모듈 → 여러 하위 기능 필요 
* 저수준 모듈 : 하위 기능을 실제로 구현한 것 
* 여기서 DIP를 적용하게 되면, 저수준 모듈이 고수준 모듈에 의존하도록 바꿀 수 있음
  * 고수준 모듈에서 추상화된 인터페이스 제공
  * 저수준 모듈은 인터페이스를 상속받아 구현 → 해당 방법을 사용하여 고수준 모듈은 어떤 저수준 모듈이 오더라도 받아들일 수 있음 
* 처음 계층 구조에서 발생했던, 상위 계층이 하위 계층에 의존했던 것을 하위 계층이 상위 계층에 의존하게 하는 것, 즉 기존의 의존관계를 반대로 역전시키는 것을 DIP \(Dependency Inversion Principle, 의존성 역전 원칙\)이라고 함 
* 장점
  1. 구현 기술 교체의 어려움 해결
     * 실제 구현은 저수준에서 이루어지지만, 고수준 모듈에서는 추상화된 인터페이스를 거쳐서 전달받기 때문에 수정의 전파가 이루어지지 않음
  2. 테스트 문제 해결
     * 기존에 인프라스트럭처 영역에 종속된 것을 인터페이스를 통하여 받기 때문에 실제 구현된 인프라스트럭처 영역이 필요한 것이 아닌, 대응 객체를 사용하여 테스트 수행 가능 → 각 영역 별로 따로 테스트를 진행할 수 있게 됨
* 주의사항
  * DIP 적용 시 추상화 인터페이스는 고수준 모듈 관점에서 도출
  * 고수준 모듈에서 저수준 모듈에게 창구를 열어준다는 개념으로 이해

## 도메인 영역의 주요 구성요소

* 엔티티
  * 고유한 식별자를 갖는 객체
  * `도메인의 고유한 개념` 표현
  * `도메인 모델의 데이터` 를 포함하여 `해당 데이터와 관련된 기능` 을 함께 제공 
* 밸류
  * 고유한 식별자를 갖지 않는 객체
  * 개념적으로 하나인 도메인 객체의 `속성` 을 표현할 때 사용 
* 애그리거트

  * 관련된 엔티티와 밸류 객체들을 `개념적으로 하나로 묶은 것` 

* 리포지토리

  * 도메인 모델의 `영속성` 처리

* 도메인 서비스
  * `특정 엔티티에 속하지 않은` 도메인 로직 제공

> 도메인 모델의 엔티티 vs DB 모델의 엔티티  
> 1. 도메인 모델의 엔티티  
>     - 데이터와 함께 도메인 기능 제공  
>     - 기능 구현을 **캡슐화**하여 **데이터가 임의로 변경되는 것을 막음**  
>     - 두 개의 데이터가 개념적을 하나를 나타낼 경우 밸류 타입을 이용해서 표현 가능
>
> 2. DB 모델의 엔티티  
>     - 밸류 타입을 제대로 표현하기 어려움



