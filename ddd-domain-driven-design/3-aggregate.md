# 3장 Aggregate\(애그리거트\)

* 도메인 객체 모델이 점점 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려움
  * 위 내용은 곧 개념 간 관계 파악이 어렵다는 문제와 직결, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워짐

#### 애그리거트

* 관련된 도메인 객체들을 하나의 군으로 묶어 관리
* 일관성을 관리하는 기준

  > 일관성?

* 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 가진다.
* 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
* 애그리거트 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항
  * 도메인 규칙에 의해 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높음
  * 함께 변경되는 빈도가 높은 객체는 한 애그리거트에 속할 가능성이 높음
  * 하지만,  has-a 관계에 속한다고 반드시 같은 애그리거트에 속하는 것은 아님

    > 쇼핑몰에서 상품과 리뷰의 관계라고 생각하면 편하다.

    > 상품과 리뷰는 함께 생성되지도, 함께 변경되지도 않음
    >
    > 상품의 변경 주체는 상품 담당자 / 리뷰의 변경 주체는 고객
    >
    > 리뷰의 변경이 상품에 영향을 주지 않고, 상품의 변경이 리뷰에 영향을 주지 않기 때문에 한 애그리거트에 속한다고 할 수 없음
* 애그리거트 루트
  * 애그리거트는 여러 객체로 구성되기 때문에 모든 객체의 상태가 정상이어야 함
  * 애그리거트에 속한 모든 객체가 일관된 상태로 유지하기 위해 애그리거트 전체를 관리하는 주체
    * 애그리거트에 속한 모든 객체는 애그리거트 루트 객체에 직/간적으로 속함
  * 애그리거트의 일관성이 깨지지 않도록 하는 것
    * 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안됨
  * 애그리거트 루트는 애그리거트가 제공해야할 도메인 기능을 구현
    * 해당 객체로만 애그리거트에 대해 기능을 수행할 수 있다고 이해함
  * 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을  구현하기 위한 방법
    1. set 메소드를 public으로 만들지 않기
       * 도메인 로직이 도메인 객체가 아닌, 응용이나 표현 영역에 분산되게 만드는 원인
    2. 밸류 타입을 불변으로 선언하기
       * 애그리거트 외부에서 밸류 타입에 접근할 수 있을 경우 일관성이 깨질 가능성이 높음
  * 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합하여 기능을 완성
    * 구성요소의 상태만 참조하는 것이 아닌, 기능 실행을 위임하여 구현하기도  함
    * 보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 범위 지정자를 활용하여 애그리거트 외부에서의 상태 변경을 방지할 수 있다.

