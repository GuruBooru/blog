# 6장 응용 서비스와 표현 영역

## 표현 영역과 응용 영역

* 사용자와 도메인을 연결해 주는 매개체 역할

### 표현 영역

* 사용자의 요청을 해석
* 요청을 받은 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용하여 **사용자가 어떤 기능을 실행하고 싶어 하는지 판별, 그 기능을 제공하는 응용 서비스 실행**
* 응용 서비스가 요구하는 형식으로 사용자 요청 변환

### 응용 영역

* 사용자가 원하는 기능을 제공
* 도메인 객체를 사용하여 사용자의 요청 처리
* 주로 도메인 객체 간의 흐름 제어
* 트랜잭션 처리

#### 도메인 로직 넣지 않기

* 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현할 경우 코드 품질에 문제
  1. 코드의 응집성 ↓
     * 도메인 로직을 분석하기 위해서 여러 영역을 분석해야함 
  2. 코드의 중복
     * 도메인 로직을 도메인 영역에서만 구현했다면, 해당 로직을 가져다 사용하면 되지만, 여러 영역에 분산하여 구현한 경우, 해당 로직이 필요한 영역마다 로직을 다시 구현 
* 도메인 로직이 응용 서비스에 출현하면서 발생하는 문제는 코드 변경을 어렵게 만듦

## 응용 서비스의 구현

#### 응용 서비스의 크기

* 한 응용 서비스 클래스에 모든 기능 구현
  * 각 메소드를 구현하는데 필요한 리포지터리나 도메인 서비스를 필드로 추가
  * 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로, 각 기능에서 동일 로직에 대한 코드 중복 제거의 효과
  * 한 서비스 클래스에서 연관성이 적은 코드가 함께 위치하면서 코드의 응집도가 떨어질 수 있음 
* 구분되는 기능 별로 응용 서비스 클래스 구현
  * 한 클래스에 관련 기능을 모두 구현하는 것과 비교하여 코드 품질을 일정 수준 유지하는데 도움
  * 다른 기능을 구현한 코드에 영향 받지 않음
  * 여러 클래스에 동일한 코드를 중복하여 구현할 가능성이 높음 → 별도의 클래스에 로직을 구현하여 코드 중복 방지

#### 응용서비스의 인터페이스와 클래스

* 구현 클래스가 다수 존재하거나, 런타임에 구현 객체를 교체하는 경우 인터페이스는 유용하게 사용할 수 있음 하지만, 런타임에 구현 객체를 교체하는 경우는 거의 없고, 응용 서비스의 구현 클래스가 두 개인 경우는 드물다. → 인터페이스가 명확하게 필요하기 전까지 응용 서비스에 대한 인터페이스르 작성하는 것이 좋은 설계라고 보기 힘듦 
* TDD와 표현 영역부터 개발하는 경우, 응용 서비스를 미리 구현할 수 없으므로 응용 서비스의 인터페이스부터 작성
* 도메인 영역이나 응용 영역의 개발을 먼저 시작할 경우 응용 서비스의 클래스가 먼저 만들어짐 표현 영역의 단위 테스트를 위해 응용 서비스의 가짜 객체를 사용하기 위한 인터페이스가 필요 
* **다양한 테스트 도구는 클래스에 대해서 테스트용 가짜 객체를 만들 수 있기 때문에 응용 서비스에 대한 인터페이스가 없어도 표현 영역을 테스트 할 수 있음\(Mockito 등\) → 해당 사항으로 인해 결과적으로 응용 서비스에 대한 인터페이스 필요성을 약화**

#### 표현 영역에 의존하지 않기

* 응용 서비스의 파라미터 타입을 결정할 때 표현 영역과 관련된 타입을 사용하면 안됨
  * 응용 서비스에서 표현 영역에 대한 의존 발생 시 응용 서비스만 단독으로 테스트하기 어려워짐
  * 표현 영역의 구현 변경 시 응용 서비스의 구현도 함께 변경\(코드 수정의 전파\)
  * 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 발생할 수 있음





