# 6장 응용 서비스와 표현 영역

## 표현 영역과 응용 영역

* 사용자와 도메인을 연결해 주는 매개체 역할

### 표현 영역

* 사용자의 요청을 해석
* 요청을 받은 표현 영역은 URL, 요청 파라미터, 쿠키, 헤더 등을 이용하여 **사용자가 어떤 기능을 실행하고 싶어 하는지 판별, 그 기능을 제공하는 응용 서비스 실행**
* 응용 서비스가 요구하는 형식으로 사용자 요청 변환

### 응용 영역

* 사용자가 원하는 기능을 제공
* 도메인 객체를 사용하여 사용자의 요청 처리
* 주로 도메인 객체 간의 흐름 제어
* 트랜잭션 처리

#### 도메인 로직 넣지 않기

* 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현할 경우 코드 품질에 문제
  1. 코드의 응집성 ↓
     * 도메인 로직을 분석하기 위해서 여러 영역을 분석해야함 
  2. 코드의 중복
     * 도메인 로직을 도메인 영역에서만 구현했다면, 해당 로직을 가져다 사용하면 되지만, 여러 영역에 분산하여 구현한 경우, 해당 로직이 필요한 영역마다 로직을 다시 구현 
* 도메인 로직이 응용 서비스에 출현하면서 발생하는 문제는 코드 변경을 어렵게 만듦

## 응용 서비스의 구현

### 응용 서비스의 크기

* 한 응용 서비스 클래스에 모든 기능 구현
  * 각 메소드를 구현하는데 필요한 리포지터리나 도메인 서비스를 필드로 추가
  * 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로, 각 기능에서 동일 로직에 대한 코드 중복 제거의 효과
  * 한 서비스 클래스에서 연관성이 적은 코드가 함께 위치하면서 코드의 응집도가 떨어질 수 있음 
* 구분되는 기능 별로 응용 서비스 클래스 구현
  * 한 클래스에 관련 기능을 모두 구현하는 것과 비교하여 코드 품질을 일정 수준 유지하는데 도움
  * 다른 기능을 구현한 코드에 영향 받지 않음
  * 여러 클래스에 동일한 코드를 중복하여 구현할 가능성이 높음 → 별도의 클래스에 로직을 구현하여 코드 중복 방지

### 응용서비스의 인터페이스와 클래스

* 구현 클래스가 다수 존재하거나, 런타임에 구현 객체를 교체하는 경우 인터페이스는 유용하게 사용할 수 있음 하지만, 런타임에 구현 객체를 교체하는 경우는 거의 없고, 응용 서비스의 구현 클래스가 두 개인 경우는 드물다. → 인터페이스가 명확하게 필요하기 전까지 응용 서비스에 대한 인터페이스르 작성하는 것이 좋은 설계라고 보기 힘듦 
* TDD와 표현 영역부터 개발하는 경우, 응용 서비스를 미리 구현할 수 없으므로 응용 서비스의 인터페이스부터 작성
* 도메인 영역이나 응용 영역의 개발을 먼저 시작할 경우 응용 서비스의 클래스가 먼저 만들어짐 표현 영역의 단위 테스트를 위해 응용 서비스의 가짜 객체를 사용하기 위한 인터페이스가 필요 
* **다양한 테스트 도구는 클래스에 대해서 테스트용 가짜 객체를 만들 수 있기 때문에 응용 서비스에 대한 인터페이스가 없어도 표현 영역을 테스트 할 수 있음\(Mockito 등\) → 해당 사항으로 인해 결과적으로 응용 서비스에 대한 인터페이스 필요성을 약화**

### 표현 영역에 의존하지 않기

* 응용 서비스의 파라미터 타입을 결정할 때 표현 영역과 관련된 타입을 사용하면 안됨
  * 응용 서비스에서 표현 영역에 대한 의존 발생 시 응용 서비스만 단독으로 테스트하기 어려워짐
  * 표현 영역의 구현 변경 시 응용 서비스의 구현도 함께 변경\(코드 수정의 전파\)
  * 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 발생할 수 있음 
* 위와 같은 문제를 발생하지 않도록 하기 위해서 철저하게 응용 서비스가 표현 영역의 기술을 사용하면 안된다.

### 트랜잭션 처리

* 한 기능을 수행하고 데이터를 DB에 저장하지 않으면 다른 기능을 사용할 수 없는 경우
* DB의 데이터를 변경하는 데 실패했다는 결과를 보였지만, 실제 DB에는 반영된 경우 
* 책에서는 위와 같은 경우가 트랜잭션과 관련된 중요한 문제라고 설명하고 있으며, 프레임워크의 기능을 사용하여 이를 손쉽게 처리하라고 설명

### 도메인 이벤트 처리

* 응용 서비스의 역할 중 하나

> 도메인 이벤트?  
> : 도메인에서 발생한 상태 변경  
> : 예를 들어 `암호 변경` `주문 취소` 와 같은 것  
> : 도메인 영역은 상태가 변경되면 이를 외부에 알리기 위해 이벤트를 발생시킬 수 있음

* 이벤트를 사용할 경우 코드가 다소 복잡해질 수 있으나, 도메인 간 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점



## 표현 영역

#### 표현 영역의 책임

* 사용자가 시스템을 사용할 수 있는 흐름을 제공, 제어
  * 웹 서비스의 경우 표현 영역은 사용자가 요청한 내용을 응답으로 제공
  * 응답에는 다음 화면으로 이동할 수 있는 링크나 데이터를 입력하는 데 필요한 폼 등이 포함
  * 사용자가 제공한 폼에 알맞은 값을 입력하고 다시 폼을 표현 영역에 전송하면, 표현 영역은 응용 서비스를 이용해서 표현 영역의 요청을 처리하고 결과를 응답으로 전송 
* 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
  * 화면을 보여주는 데 필요한 데이터를 읽거나, 도메인의 상태를 변경해야 할 때 응용 서비스를 사용
  * 사용자의 요청 데이터를 응용 서비스가 요구하는 형식으로 변환 응용 서비스의 결과를 사용자에게 응답할 수 있는 형식으로 변환 
* 사용자의 세션 관리
  * 세션 관리의 경우 권한 검사와도 연결

## 값 검증

* 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있음
* 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리 
* 표현 영역에 값 검증이 필요한 경우 표현 영역에 잘못된 값이 존재할 시 이를 사용자에게 알려주고 값을 다시 입력받아야 하는데,  응용 서비스에서 `각 값이 존재하는지`, `형식이 올바른지` 확인할 목적으로 익셉션을 사용하게 되면 특정 항목에 대해서 예외 발생 시 나머지 값은 확인하지 않기 때문에 사용자는 나머지 값이 올바른지 여부를 알 수 없게 됨 →**사용자에게 좋지 않은 경험을 제공하게 됨** 
* 이러한 불편을 감소하기 위해 표현 영역에서 값 검증을 수행하기도 함
  * 표현 영역 : 필수 값, 값의 형식, 범위 등을 검증
  * 응용 서비스 : 데이터의 존재 유무와 같은 논리적 오류 검증

## 권한 검사

* 보안 프레임워크의 복잡도를 떠나 보통 `표현 영역` `응용 서비스` `도메인` 이 세 곳에서 권한 검사 수행
  * 표현 영역에서 할 수 있는 가장 기본적인 검사는 인증된 사용자인지 아닌지 여부를 검사 주로 URL을 활용하여 제어
  * URL 만으로 접근 제어를 할 수 없는 경우, 응용 서비스의 메소드 단위로 권한 검사 수행
  * 개별 도메인 단위로 권한 검사를 수행하는 경우는 구현이 다소 복잡해짐\(직접 구현\)

## 조회 전용 기능과 응용 서비스

* 별도의 조회 전용 모델과 DAO를 만든 경우, 서비스에서 해당 기능을 사용하게 되면 서비스 코드가 단순히 조회 전용 기능을 호출하는 것으로 끝나는 경우가 발생
* 위와 같은 상황에서 추가적인 로직이 없고, 조회 전용이기에 트랜잭션이 필요하지도 않기 때문에 표현 영역에서 조회 전용 기능을 사용해도 좋다고 설명하고 있음 → 응용 서비스가 사용자 요청 기능을 실행하는 데 별 다른 기여를 하지 못할 경우 굳이 서비스를 만들지 않아도 됨
* DDD 자체의 목적이 개발의 편의성을 위해 계층을 분리하고, 기능을 모아둔다고 생각 따라서 책에서 설명한 위와 같은 행동은 문제될 것이 없다고 생각한다.



\*\*\*\*









