# 8장 애그리거트 트랜잭션 관리

## 애그리거트와 트랜잭션

* 개념적으로는 동일한 애그리거트이지만, 물리적으로 서로 다른 애그리거트 객체를 사용할 수 있음
* 애그리거트 객체가 서로 다른 스레드에서 동작할 경우, 두 스레드는 각각 트랜잭션을 커밋할 때 수정한 내용을 DBMS에 반영한다.
* 이 과정에서 서로 데이터가 가지고 있는 데이터만 가지고 진행하게 된다면, DB에 저장된 데이터와 애그리거트 객체가 가지고 있는 데이터가 달라지는, 즉 `애그리거트의 일관성` 이 깨지게 된다. 
* 이러한 문제가 발생하지 않도록 하기 위해  


  1. 한 스레드에서 조회, 상태 변경을 진행하는 동안 다른 스래드에서 수정하지 못하도록 제한
  2. 한 스레드에서 조회 후 다른 스레드에서 정보 변경을 하면, 조회를 하는 스레드가 다시 조회 후 수정 

  이 진행되어야 한다.

## 선점 잠금

* 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식

![&#xC120;&#xC810; &#xC7A0;&#xAE08;&#xC758; &#xB3D9;&#xC791; &#xBC29;&#xC2DD;](../.gitbook/assets/image%20%2815%29.png)

* 보통 DBMS에서 제공하는 행 단위 잠금을 사용하여 구현한다고 설명하고 있음
  * 오라클을 비롯한 다수의 DBMS에 있는 for update 쿼리
  * JPA의 find\(\) 메소드에 LockModeType.PESSIMISTIC\_WRITE 값 전달 등 
* 선점 잠금의 경우 데드락이 발생하지 않게 하는 것이 중요
  * 사용자 수가 많을 때 발생할 가능성 ↑
  * 사용자 수가 많아지면 교착 상태에 빠지는 스레드 ↑ 
* 데드락 방지를 위해 최대 대기 시간 지정

  * JPA의 경우 힌트를 사용하여 대기 시간 지정\(밀리초 단위\)
  * DBMS에 따라 쿼리 단위로 대기 시간을 지정, 커넥션 단위로 대기 시간 지정이 따로 존재 어떤 방식으로 처리하는지 확인해야함

## 비선점 잠금

* 선점 잠금이 강력해 보이지만, 모든 트랜잭션 충돌 문제를 처리할 수는 없음  


  1. 스레드 A에서 정보 조회
  2. 스레드 B에서 변경 요청, 시스템은 변경 폼 제공
  3. 스레드 B에서 폼 전송
  4. 스레드 A에서 조회한 정보를 기준으로 변경 요청 

  이와 같은 상황이 생길 수 있음  
  `정보 조회` 에서 선점 잠금을 수행하기 때문에 정보 조회를 요청한 후에는 잠금을 따로 수행하지 않음 → 모든 부분에서 잠금을 수행하기에는 비효율적  

* 비선점 잠금 방식은 동시에 접근하는 것을 막는 것이 아닌, 변경한 데이터를 실제 DBMS에 반영하는 시점에서 변경 가능 여부를 확인
* 따라서 비선점 잠금을 구현할 경우 애그리거트에 버전으로 사용할 숫자 타입의 프로퍼티를 추가\(애그리거트에 대한 버전이라고 생각하면 이해하기 쉬움\)
  * JPA의 경우 버전을 이용한 비선점 잠금 지원

![&#xBE44;&#xC120;&#xC810; &#xC7A0;&#xAE08;&#xC758; &#xB3D9;&#xC791; &#xBC29;&#xC2DD;](../.gitbook/assets/image%20%2812%29.png)

### 강제 버전 증가

* 애그리거트에 애그리거트 루트 외에 다른 엔티티가 존재, 기능 실행 도중 루트가 아닌 다른 엔티티의 값만 변경될 경우 루트 엔티티의 버전 값을 증가하지 않음
* 하지만 이 경우 루트 엔티티는 바뀌지 않았어도, 애그리거트의 구성요소 중 일부 값이 바뀌었기 때문에 논리적으로 애그리거트는 바뀌었다고 처리해야함
* 따라서 애그리거트 내에 어떤 구성요소의 상태가 바뀌면 루트 애그리거트의 버전 값을 증가해야 비선점 잠금이 올바르게 동작

## 오프라인 선점 잠금

* 아틀라시안의 컨플루언스 위키는 문서를 편집하려고 하면 다른 사용자가 문서를 수정한다는 안내 문구를 보여주며 여러 사용자가 동시에 한 문서를 수정할 때 발생하는 충돌을 사전에 방지 하지만 수정 자체를 막지는 않음
* 수정 자체를 막고 싶은 경우, 누군가 수정 화면을 보고 있을 때 수정 화면 자체를 실행하지 못하도록 해야함 이는 한 트랜잭션 범위에서만 적용되는 선점 잠금이나, 비선점 잠금 방식으로는 구현이 불가능
* 오프라인 선점 잠금의 경우 여러 트랜잭션에 걸쳐 동시 변경을 막음
  * 첫 번째 트랜잭션 시작 시 오프라인 잠금 선점
  * 마지막 트랜잭션에서 잠금 해제
  * 잠금이 진행되는 동안 다른 사용자는 잠금을 구할 수 없음 
* 오프라인 선점 잠금 주요 기능
  1. 잠금 선점 시도
  2. 잠금 확인
  3. 잠금 해제
  4. 락 유효 시간 연장



