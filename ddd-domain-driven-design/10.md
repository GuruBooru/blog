# 10장 이벤트

## 시스템 간 강결합의 문제

* 도메인 서비스를 이용하여 기능을 수행할 때, 그 기능이 외부 시스템을 호출하여 해결하는 경우,

  1. **외부 서비스가 정상이 아닐 경우 트랜잭션 처리에 대한 문제**
     * `기능을 실행하는 과정에서 익셉션이 발생`하면 `트랜잭션 롤백`? `커밋`?
  2. **성능에 대한 문제**
     * 외부 시스템의 응답 시간이 길어지면, 대기 시간 발생 → 성능 저하
  3. **도메인 객체에 서비스 전달 시 발생하는 설계상 문제**
     * 도메인 객체에 서로 다른 도메인 로직이 섞이는 문제
     * 기능 추가 시 해당 방법을 사용한다면, 더 많은 로직이 섞이고, 트랜잭션 처리가 복잡해지며, 외부 서비스가 증가할 수 있음

  가 발생할 수 있다.  

* 위와 같은 상황은 한 Bounded Context가 다른 Bounded Context에 강하게 결합되어 있기 때문
* 이벤트를 사용하여 이러한 강결합을 없앨 수 있음

## 이벤트

* 이벤트가 발생한다는 것은 상태가 변경됐다는 것을 의미
* 이벤트 발생 시 그 이벤트에 반응하여 원하는 동작을 수행하는 기능 구현
* 도메인 모델에서 UI 컴포넌트와 유사하게 도메인의 상태 변경을 이벤트로 표현할 수 있음

### 이벤트 관련 구성요소

* 이벤트 구성요소
  * 이벤트 생성 주체
  * 이벤트 디스패처
  * 이벤트 핸들러
  * 이벤트 
* 이벤트 생성 주체
  * 도메인 모델에서 이벤트 주체는 `엔티티`, `밸류`, `도메인 서비스`와 같은 도메인 객체
  * 도메인 객체는 도메인 로직을 실행하여 상태가 바뀌면 관련 이벤트 발생 
* 이벤트 핸들러
  * 이벤트 생성 주체가 발생한 이벤트에 반응
  * 이벤트를 전달받아 이벤트에 담긴 데이터를 이용하여 원하는 기능 실행 
* 이벤트 디스패처
  * 이벤트 생성 주체와 이벤트 핸들러를 연결해 주는 역할
  * 구현 방식에 따라 이벤트 생성과 처리를 동기, 비동기 처리

### 이벤트의 구성

* 이벤트는 발생항 이벤트에 대한 정보를 담는다.
  * 이벤트 종류 : 클래스 이름으로 이벤트 종류 표현
  * 이벤트 발생 시간
  * 추가 데이터 : 이벤트와 관련된 정보

### 이벤트 용도

1. 트리거
   * 도메인의 상태가 바뀔 때 다른 후처리를 해야 할 경우, `후처리를 실행하기 위한 트리거`로 사용
2. 서로 다른 시스템 간의 데이터 동기화

### 이벤트 장점

* 서로 다른 도메인 로직이 섞이는 것을 방지
  * 도메인의 상태가 바뀌었을 때 이벤트를 발생하여 이벤트 핸들러에서 처리하기 때문에 도메인에서 다른 도메인의 로직을 수행할 필요 없음
* 기능 확장에 용이
  * 해당 기능을 처리하는 이벤트 핸들러를 구현, 디스패처에 등록하여  기능을 확장하여도 도메인 로직을 수정할 필요 없이 이벤트 핸들러가 디스패처를 통해 이벤트를 받아 처리

## 구현

### 이벤트 클래스

* 이벤트 자체를 위한 상위 타입은 존재하지 않음
* 원하는 클래스를 이벤트로 사용
* 이벤트 클래스는 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함
* 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면, 관련 상위 클래스를 만들 수 있음

### 이벤트 핸들러 인터페이스

* 이벤트 핸들러를 위한 상위 인터페이스
* 해당 인터페이스를 상속받은 핸들러 클래스는 이벤트 처리를 위한 handle 메소드 구현
* canHandle 메소드를 통해 핸들러가 이벤트를 처리할 수 있는지 여부를 검사

### 이벤트 디스처 구현

* 도메인을 사용하는 응용 서비스는 이벤트를 받아 처리할 핸들러를 디스패처.handle로 등록
* raise 메소드를 사용하여 이벤트 발생
* 이벤트 발생 후 등록된 이벤트 핸들러 리스트를 순회하며 이벤트 핸들러.handle 메소드 수행
* 사용자 요청 처리 후, 리셋하지 않으면, 핸들러 객체가 계속 쌓여 잘못된 동작을 유발하거나, 메모리 부족 에러가 발생할 수 있음

![](../.gitbook/assets/image%20%2816%29.png)

## 동기 이벤트 처리 문제

* 외부 서비스와 연동하여 서비스가 느려지게 될 경우, 해당 기능 자체가 느려진다.
* 트랜잭션에 있어 롤백이 무조건 정답이 아닐 수 있음
* 이러한 문제를 해결하기 위해 이벤트를 비동기로 처리

## 비동기 이벤트 처리

* 후속조치가 바로 할 필요 없이 `일정 시간 안에만 처리하면 되는 경우`, `실패하면 일정 간격으로 재시도를 하거나, 수동 처리할 경우`  비동기로 구현할 수 있음
* 이벤트 발생 시 별도 스레드로 핸들러를 실행하는 방식으로 구현

### 로컬 핸들러의 비동기 실행

* 이벤트 핸들러를 별도 스레드로 실행
* 동기로 실행할 이벤트 핸들러를 처리하는 방식과 유사
* 별도 스레드를 이용하여 이벤트 핸들러 실행 시 이벤트 발생 코드와 같은 트랜잭션 범위에 묶을 수 없기 때문에 한 트랜잭션으로 실행해야 하는 이벤트 핸들러는 비동기로 처리하면 안된다.

### 메시징 시스템을 이용한 비동기 구현

* 메시지 큐를 사용하여 이벤트 처리
* 이벤트 발생 시 이벤트를 메시지 큐에 보냄
* 메시지 큐는 이벤트를 메시지 리스너에 전달,  메시지 리스너는 알맞은 이벤트 핸들러를 이용해서 이벤트 처리
* `이벤트를 메시지 큐에 저장하는 과정`, `메시지 큐에서 이벤트를 읽어와 처리하는 과정`은  별도의 스레드나 프로세스로 처리
* 도메인 기능을 실행한 결과를 DB에 반영하고, 이 과정에서 발생한 이벤트를 메시지 큐에 저장하기 위해서 `글로벌 트랜잭션` 필요
* 글로벌 트랜잭션 사용 시, 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점 전체 성능이 떨어지는 단점
* 많은 경우 메시지 큐 사용 시 이벤트를 발생하는 주체와 이벤트 핸들러가 별도 프로세스에서 동작

### 이벤트 저장소를 이용한 비동기 처리

* 이벤트를 DB에 저장한 뒤 별도 프로그램을 이용하여 이벤트 핸들러에 전달
* 포워더 방식
  * 이벤트 발생 시 핸들러는 스토리지에 이벤트 저장 포워더는 주기적으로 스토리지에서 이벤트를 가져와 이벤트 핸들러 실행 포워더는 별도의 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리 
* API 방식
  * API 서버를 통해 이벤트 목록을 가져오는 방식
  * 자신이 어디까지 이벤트를 처리했는지 기억해야 함 
* 도메인의 상태와 이벤트 저장소로 동일한 DB 사용
* 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리
* 이벤트를 물리적 저장소에 저장하기 때문에 이벤트 처리에 실패할 경우, 다시 이벤트를 읽어와 핸들러 실행

## 이벤트 적용 시 추가 고려사항

1. 이벤트 소스를 EventEntry에 추가할지 여부
2. 포워더에서 전송 실패를 얼마나 허용할 것이냐에 대한 것
3. 이벤트 손실
4. 이벤트 순서
5. 이벤트 재처리

> 이벤트 처리에 있어 동일 이벤트를 한 번 적용하나, 여러 번 적용하나 시스템이 같은 상태가 되도록 핸들러를 구현할 수 있음
>
> 이처럼 이벤트 핸들러가 멱등성을 가지면 시스템 장애로 인해 이벤트가 중복해서 발생해도 결과적으로 동일 상태가 된다. → 이벤트 중복 발생이나 중복 처리에 대한 부담을 줄여줌

